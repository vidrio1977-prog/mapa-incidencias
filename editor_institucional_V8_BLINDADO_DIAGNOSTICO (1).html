<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Editor Institucional V8 Blindado - Editor institucional V8 BLINDADO — rutas, incidencias, medición</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    html, body { height:100%; margin:0; }
    #map { height:100%; }

    .panel{
      position:absolute; top:10px; left:10px; z-index:1000;
      width: 420px; max-height: calc(100% - 20px); overflow:auto;
      background: rgba(255,255,255,0.96);
      padding: 12px; border-radius: 14px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    h3{ margin:0 0 10px; font-size: 15px; }
    .tabs{ display:flex; gap:8px; margin-bottom:10px; }
    .tab{ padding:8px 10px; border-radius:999px; border:1px solid #ddd; background:#fff; cursor:pointer; font-size:13px; }
    .tab.active{ background:#1f6feb; color:#fff; border-color:#1f6feb; }
    .section{ display:none; }
    .section.active{ display:block; }

    label{ display:block; font-size:12px; color:#444; margin: 8px 0 4px; }
    input, textarea, select, button{
      width:100%; box-sizing:border-box;
      padding:8px; border:1px solid #ccc; border-radius:10px;
      font-size:13px;
    }
    textarea{ min-height: 86px; resize: vertical; }
    button{ border:none; cursor:pointer; background:#1f6feb; color:#fff; }
    button.secondary{ background:#6c757d; }
    button.good{ background:#198754; }
    button.danger{ background:#dc3545; }
    button.ghost{ background:#fff; color:#1f6feb; border:1px solid #cfe0ff; }
    .row{ display:flex; gap:8px; margin-top:8px; }
    .row > *{ flex:1; }
    .small{ font-size:12px; color:#666; line-height:1.25; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; font-size:12px; }
    .hr{ height:1px; background:#e2e2e2; margin:12px 0; }

    .status{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px; color:#444; }
    .dot{ width:8px; height:8px; border-radius:50%; background:#bbb; display:inline-block; }
    .dot.ok{ background:#198754; }
    .dot.warn{ background:#fb8c00; }

    .toggle{
      display:flex; gap:10px; align-items:center;
      border:1px solid #ddd; border-radius: 12px; padding: 8px;
      background: rgba(250,250,250,0.9);
      margin-top: 8px;
    }
    .toggle input{ width:auto; }

    .routeList{ margin-top:10px; display:flex; flex-direction:column; gap:8px; }
    .routeCard{
      border:1px solid #e2e2e2; border-radius: 12px; padding: 10px;
      background:#fff;
    }
    .routeTop{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .routeName{ font-weight:700; font-size:13px; }
    .routeMeta{ font-size:12px; color:#666; margin-top:4px; }
    .routeActions{ display:flex; gap:6px; margin-top:8px; }
    .routeActions button{ padding:7px 8px; font-size:12px; border-radius:10px; }
    .routeActions button.secondary{ background:#eef2f7; color:#1f2937; border:1px solid #d9e0ea; }
    .routeActions button.danger{ background:#ffe9ea; color:#b4232a; border:1px solid #ffd1d4; }
    .routeActions button.ghost{ background:#fff; color:#1f6feb; border:1px solid #cfe0ff; }
    .routeColorRow{ display:flex; gap:8px; align-items:center; margin-top:8px; }
    .routeColorRow input[type="color"]{ width:52px; height:36px; padding:0; border-radius:10px; border:1px solid #ccc; }
    .routeColorRow button{ flex:1; }

    .reviewBar{
      display:flex; gap:8px; align-items:center; margin-top:8px;
    }
    .reviewBar button{ padding:8px; border-radius:10px; }
    .kpi{
      display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px;
    }
    .kpiCard{
      border:1px solid #e2e2e2; border-radius: 12px; padding:10px; background:#fff;
    }
    .kpiNum{ font-weight:800; font-size:18px; }
    .kpiLbl{ font-size:12px; color:#666; margin-top:2px; }

    .measureBox{
      border:1px solid #e2e2e2; border-radius: 12px; padding:10px; background:#fff;
      margin-top:10px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body>
<div id="map"></div>

<div class="panel">
  <h3>Editor institucional (rutas + incidencias)</h3>

  <div class="tabs">
    <button class="tab active" data-tab="rutas">Rutas</button>
    <button class="tab" data-tab="punto">Punto</button>
    <button class="tab" data-tab="analisis">Análisis</button>
  </div>

  <!-- RUTAS -->
  <div class="section active" id="tab-rutas">
    <label>Importar GeoJSON (añadir)</label>
    <input id="fileInput" type="file" multiple accept=".geojson,application/geo+json,application/json,.json"/>

    
    <div class="toggle" style="margin-top:8px;">
      <input id="importReplace" type="checkbox"/>
      <div>
        <div style="font-weight:700; font-size:13px;">Importar reemplazando (no añadir)</div>
        <div class="small">Si activas esto, cada importación limpia el mapa antes de cargar (evita triplicados).</div>
      </div>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="clearMapBtn" class="danger">Vaciar mapa (quitar todo)</button>
      <button id="newSessionBtn" class="secondary">Empezar limpio (también borra guardado)</button>
    </div>

    <div class="small" id="importLog" style="margin-top:8px;"></div>
<div class="toggle">
      <input id="autoSaveToggle" type="checkbox" checked />
      <div>
        <div style="font-weight:700; font-size:13px;">Guardado automático</div>
        <div class="small">Guarda al importar, mover, editar, borrar, recolorear.</div>
      </div>
    </div>

    <div class="row">
      <button id="saveBtn" class="good">Guardar ahora</button>
      <button id="loadBtn" class="secondary">Cargar guardado</button>
    </div>

    <div class="row">
      <button id="exportBtn">Exportar todo</button>
      <button id="fitBtn" class="secondary">Ajustar vista</button>
    </div>

    <div class="row">
      <button id="clearBtn" class="danger">Borrar guardado</button>
      <button id="exportRouteBtn" class="secondary">Exportar ruta</button>
    </div>

    <div class="status" style="margin-top:8px;">
      <span class="dot" id="saveDot"></span>
      <span id="saveStatus">Sin cambios pendientes</span>
      <span class="small" id="saveHint"></span>
    </div>

    <div class="hr"></div>

    <label>Filtro por ruta</label>
    <select id="routeFilter">
      <option value="">(todas)</option>
    </select>

    <label>Buscar texto</label>
    <input id="searchBox" placeholder="Ej: Foto 14, desprendimiento…"/>

    
    <div class="measureBox" id="routeMetricsBox" style="margin-top:10px;">
      <div style="font-weight:800; font-size:13px;">Ruta seleccionada</div>
      <div class="mono small" id="routeMetricsOut" style="margin-top:6px;">Selecciona una ruta para ver distancia y tiempo.</div>
      <div class="row" style="margin-top:8px;">
        <div>
          <label style="margin:0 0 4px;">Velocidad estándar (km/h)</label>
          <input id="speedStdRoutes" type="number" step="0.1" value="4.0"/>
        </div>
        <div>
          <label style="margin:0 0 4px;">Velocidad adaptada (km/h)</label>
          <input id="speedAccRoutes" type="number" step="0.1" value="2.5"/>
        </div>
      </div>
    </div>
<div class="routeList" id="routeList"></div>

    <div class="small" style="margin-top:10px;">
      <b>PN</b> siempre en blanco. Mover puntos: herramienta <b>Editar</b> (arriba derecha).
      Satélite: selector de capas (arriba derecha).
    </div>
  </div>

  <!-- PUNTO -->
  <div class="section" id="tab-punto">
    <div class="badge" id="selBadge">Sin selección</div>

    <label>Ruta</label>
    <input id="fRuta" placeholder="Ej: 27 o PN07"/>

    
    <label>Nombre de ruta</label>
    <input id="fRutaNombre" placeholder="Ej: Chipude – PN"/>
<div class="row">
      <div>
        <label>Foto</label>
        <input id="fFoto" placeholder="Ej: 14"/>
      </div>
      <div>
        <label>Color ruta</label>
        <input id="fColor" type="color" value="#d32f2f"/>
      </div>
    </div>

    <label>Incidencia</label>
    <textarea id="fIncidencia" placeholder="Texto de incidencia..."></textarea>

    <div class="row">
      <button id="savePointBtn">Guardar punto</button>
      <button id="deletePointBtn" class="danger">Eliminar punto</button>
    </div>

    <div class="row">
      <button id="applyRouteColorBtn" class="secondary">Cambiar color ruta completa</button>
      <button id="deleteRouteBtn" class="danger">Borrar ruta completa</button>
    </div>

    <div class="toggle">
      <input id="addMode" type="checkbox" />
      <div>
        <div style="font-weight:700; font-size:13px;">Modo añadir puntos</div>
        <div class="small">Activa y haz click en el mapa para crear un punto.</div>
      </div>
    </div>
  </div>

  <!-- ANÁLISIS -->
  <div class="section" id="tab-analisis">
    <div class="kpi">
      <div class="kpiCard">
        <div class="kpiNum" id="kpiRoutes">0</div>
        <div class="kpiLbl">Rutas</div>
      </div>
      <div class="kpiCard">
        <div class="kpiNum" id="kpiPoints">0</div>
        <div class="kpiLbl">Incidencias</div>
      </div>
      <div class="kpiCard">
        <div class="kpiNum" id="kpiPN">0</div>
        <div class="kpiLbl">Incidencias PN</div>
      </div>
      <div class="kpiCard">
        <div class="kpiNum" id="kpiShown">0</div>
        <div class="kpiLbl">Visibles (filtro)</div>
      </div>
    </div>

    <div class="measureBox">
      <div style="font-weight:800; font-size:13px;">Medir distancia y tiempo</div>
      <div class="small" style="margin-top:4px;">
        Pulsa <b>Iniciar medición</b>, marca puntos en el mapa, y termina.
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="measureStart" class="ghost">Iniciar medición</button>
        <button id="measureFinish" class="secondary">Terminar</button>
      </div>

      <div class="row">
        <button id="measureClear" class="danger">Borrar medición</button>
        <button id="measureFit" class="secondary">Ver medición</button>
      </div>

      <label>Velocidad estándar (km/h)</label>
      <input id="speedStd" type="number" step="0.1" value="4.0"/>

      <label>Velocidad adaptada (km/h)</label>
      <input id="speedAcc" type="number" step="0.1" value="2.5"/>

      <div class="hr"></div>

      <div class="mono small" id="measureOut">Distancia: — · Tiempo: —</div>
    </div>

    <div class="measureBox">
      <div style="font-weight:800; font-size:13px;">Revisión guiada (impacto en sala)</div>
      <div class="small" style="margin-top:4px;">Recorre incidencias visibles con zoom suave.</div>
      <div class="reviewBar">
        <button id="revPrev" class="secondary">◀</button>
        <button id="revPlay" class="ghost">▶</button>
        <button id="revNext" class="secondary">▶▶</button>
        <button id="revStop" class="danger">■</button>
      </div>
      <div class="mono small" id="revOut" style="margin-top:8px;">—</div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

<script>
/* ===========================
   IndexedDB (guardado grande)
=========================== */
const DB_NAME = "incidencias_editor_db";
const DB_VERSION = 1;
const STORE = "states";
const STATE_KEY = "latest_v2";

function openDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbSet(key, value){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).put(value, key);
    tx.oncomplete = () => { db.close(); resolve(); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}
async function idbGet(key){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = () => { db.close(); resolve(req.result); };
    req.onerror = () => { db.close(); reject(req.error); };
  });
}
async function idbDel(key){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).delete(key);
    tx.oncomplete = () => { db.close(); resolve(); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

/* ===========================
   Mapa + capas
=========================== */
const map = L.map('map').setView([28.12, -17.24], 12);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19, attribution:'&copy; OpenStreetMap' });
const sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom:19, attribution:'Tiles &copy; Esri' });

osm.addTo(map);
L.control.layers({ "Mapa (OSM)": osm, "Satélite": sat }, {}, { position:"topright" }).addTo(map);

const allLayers = L.featureGroup().addTo(map);
let selectedLayer = null;

// Estilos y colores por ruta
const palette = [
  "#e53935","#8e24aa","#3949ab","#1e88e5","#00897b","#43a047",
  "#f4511e","#6d4c41","#546e7a","#c0ca33","#fb8c00","#d81b60",
  "#5e35b1","#039be5","#00acc1","#7cb342","#fdd835","#ff7043",
  "#c62828","#ad1457","#283593","#1565c0","#00695c","#2e7d32",
  "#ef6c00","#4e342e","#37474f","#9e9d24","#f9a825","#c2185b",
  "#4527a0","#0277bd","#00838f","#558b2f"
];
let paletteIndex = 0;
const routeColors = new Map();
const routeDistanceCache = new Map(); // ruta -> { km, key }
let geometryVersion = 0; // incrementa cuando cambian coordenadas o rutas
const importedKeySet = new Set(); // para evitar duplicados al importar
 // ruta -> color
const routeHidden = new Set(); // rutas ocultas (toggle)

function safeStr(x){ return (x===undefined || x===null) ? "" : String(x); }
function getRuta(p){ return safeStr(p.ruta || p.ruta_num || p.ruta_id).trim(); }
function isPN(r){ return (r||"").toUpperCase().includes("PN"); }

function ensureRouteColor(r){
  if (!r) return "#d32f2f";
  if (isPN(r)) return "#ffffff";
  if (!routeColors.has(r)){
    routeColors.set(r, palette[paletteIndex % palette.length]);
    paletteIndex++;
  }
  return routeColors.get(r);
}

function escapeHtml(str){
  return String(str ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function normalizeGeoJson(input){
  if (!input) return null;
  if (input.type === "FeatureCollection" && Array.isArray(input.features)) return input;
  if (input.type === "Feature") return { type:"FeatureCollection", features:[input] };
  return null;
}

function featureImportKey(feature){
  try{
    const g = feature.geometry || {};
    if (g.type !== "Point" || !Array.isArray(g.coordinates)) return null;
    const lon = Number(g.coordinates[0]);
    const lat = Number(g.coordinates[1]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    const p = feature.properties || {};
    const ruta = (safeStr(p.ruta || p.ruta_num || p.ruta_id)).trim();
    const foto = safeStr(p.foto).trim();
    const inc  = safeStr(p.incidencia).trim().toLowerCase().replaceAll(/\\s+/g," ");
    const latR = Math.round(lat * 1e6) / 1e6;
    const lonR = Math.round(lon * 1e6) / 1e6;
    return `${ruta}||${foto}||${inc}||${latR}||${lonR}`;
  } catch(e){
    return null;
  }
}

function clearAllMap(alsoResetKeys=true){
  allLayers.clearLayers();
  selectedLayer = null;
  document.getElementById("selBadge").textContent = "Sin selección";
  routeColors.clear();
  routeHidden.clear();
  routeDistanceCache.clear();
  geometryVersion++;
  paletteIndex = 0;

  document.getElementById("routeFilter").innerHTML = '<option value="">(todas)</option>';
  document.getElementById("routeFilter").value = "";
  document.getElementById("searchBox").value = "";
  document.getElementById("routeList").innerHTML = "";
  updateRouteMetricsBox("");
  updateKPIs(0);

  measuring = false;
  measurePts = [];
  redrawMeasure();
  reviewRouteIdx = -1;
  reviewPointIdx = -1;
  document.getElementById("revOut").textContent = "—";
  if (reviewTimer){ clearInterval(reviewTimer); reviewTimer = null; }

  if (alsoResetKeys) importedKeySet.clear();
}

function buildPopup(p){
  const ruta = getRuta(p);
  const foto = safeStr(p.foto).trim();
  const inc = safeStr(p.incidencia).trim();
  const nombre = safeStr(p.ruta_nombre).trim();
  const titulo = `${ruta}${nombre ? " · " + nombre : ""}${foto ? " · Foto " + foto : ""}`;
  return `<b>${escapeHtml(titulo || "(sin ruta)")}</b><br>` + (inc ? escapeHtml(inc) : "<i>(sin incidencia)</i>");
}

function applyStyle(layer){
  const p = layer.feature?.properties || {};
  const ruta = getRuta(p);
  const color = isPN(ruta) ? "#ffffff" : (safeStr(p.color).trim() || ensureRouteColor(ruta));
  layer.setStyle({ radius:6, color:"#000", weight:1, fillColor: color, fillOpacity: 0.9 });
}

function pointToLayer(feature, latlng){
  const p = feature.properties || {};
  const ruta = getRuta(p);
  const color = isPN(ruta) ? "#ffffff" : (safeStr(p.color).trim() || ensureRouteColor(ruta));
  return L.circleMarker(latlng, { radius:6, color:"#000", weight:1, fillColor: color, fillOpacity:0.9 });
}

function onEachFeature(feature, layer){
  layer.bindPopup(buildPopup(feature.properties || {}), { maxWidth: 520 });
  layer.on("click", () => selectLayer(layer));
}

function selectLayer(layer){
  selectedLayer = layer;
  const p = layer.feature?.properties || {};
  const ruta = getRuta(p);

  document.getElementById("selBadge").textContent =
    `Seleccionado: ${ruta || "?"} · Foto ${safeStr(p.foto).trim() || "?"}`;

  document.getElementById("fRuta").value = ruta;
  document.getElementById("fFoto").value = safeStr(p.foto).trim();
  document.getElementById("fRutaNombre").value = safeStr(p.ruta_nombre).trim();
  document.getElementById("fIncidencia").value = safeStr(p.incidencia);

  const currentColor = isPN(ruta) ? "#ffffff" : (safeStr(p.color).trim() || ensureRouteColor(ruta));
  document.getElementById("fColor").value = currentColor;
}

/* ===========================
   Filtros y panel rutas
=========================== */
function refreshRouteFilter(){
  const select = document.getElementById("routeFilter");
  const current = select.value;

  const rutas = new Set();
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    const r = getRuta(p);
    if (r) rutas.add(r);
  });

  const sorted = Array.from(rutas).sort((a,b)=>a.localeCompare(b,"es"));
  select.innerHTML = `<option value="">(todas)</option>` + sorted.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join("");
  select.value = sorted.includes(current) ? current : "";
}

function layerMatchesFilters(layer){
  const p = layer.feature?.properties || {};
  const ruta = getRuta(p);
  const rFilter = document.getElementById("routeFilter").value.trim();
  const q = document.getElementById("searchBox").value.trim().toLowerCase();

  if (routeHidden.has(ruta)) return false;
  if (rFilter && ruta !== rFilter) return false;

  if (q){
    const inc = safeStr(p.incidencia).toLowerCase();
    const foto = safeStr(p.foto).toLowerCase();
    const rn = safeStr(p.ruta_nombre).toLowerCase();
    const rt = ruta.toLowerCase();
    if (!(inc.includes(q) || foto.includes(q) || rn.includes(q) || rt.includes(q))) return false;
  }
  return true;
}

function applyFilters(){
  let shown = 0;
  allLayers.eachLayer(l => {
    const ok = layerMatchesFilters(l);
    if (ok){
      shown++;
      l.setStyle({ opacity:1, fillOpacity:0.9 });
    } else {
      l.setStyle({ opacity:0.05, fillOpacity:0.05 });
    }
  });
  updateKPIs(shown);

  updateRouteMetricsBox(document.getElementById("routeFilter").value.trim());
}

function computeRouteStats(){
  const stats = new Map(); // ruta -> {count, pnCount}
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    const ruta = getRuta(p) || "(sin ruta)";
    const s = stats.get(ruta) || { count:0, pnCount:0 };
    s.count++;
    if (isPN(ruta)) s.pnCount++;
    stats.set(ruta, s);
  });
  return stats;
}

function renderRouteList(){
  const wrap = document.getElementById("routeList");
  const stats = computeRouteStats();
  const rutas = Array.from(stats.keys()).sort((a,b)=>a.localeCompare(b,"es"));

  wrap.innerHTML = rutas.map(r => {
    const s = stats.get(r);
    const color = isPN(r) ? "#ffffff" : (routeColors.get(r) || ensureRouteColor(r));
    const hidden = routeHidden.has(r);
    const safeR = escapeHtml(r);
    return `
      <div class="routeCard" data-route="${safeR}">
        <div class="routeTop">
          <div>
            <div class="routeName">${safeR}</div>
            <div class="routeMeta">${s.count} incidencias${isPN(r) ? " · PN" : ""}${hidden ? " · oculto" : ""} · <span class="mono">${fmtRouteKm(r)} km · ${fmtRouteTime(r)}</span></div>
          </div>
          <div class="badge" style="border:1px solid #ddd;">${hidden ? "OFF" : "ON"}</div>
        </div>

        <div class="routeColorRow">
          <input type="color" value="${color}" ${isPN(r) ? "disabled" : ""} />
          <button class="secondary btnColor" ${isPN(r) ? "disabled" : ""}>Aplicar color</button>
        </div>

        <div class="routeColorRow">
          <input type="text" class="routeNameInput" placeholder="Nombre de ruta (para toda la ruta)" value="${getRouteName(r)}" />
          <button class="secondary btnRename">Aplicar nombre</button>
        </div>

        <div class="routeActions">
          <button class="secondary btnZoom">Ver</button>
          <button class="ghost btnToggle">${hidden ? "Mostrar" : "Ocultar"}</button>
          <button class="secondary btnExport">Exportar</button>
          <button class="danger btnDelete">Borrar</button>
        </div>
      </div>
    `;
  }).join("");

  // Eventos por tarjeta
  wrap.querySelectorAll(".routeCard").forEach(card => {
    const ruta = card.getAttribute("data-route");
    const colorInput = card.querySelector('input[type="color"]');

    card.querySelector(".btnZoom").addEventListener("click", () => zoomToRoute(ruta));
    card.querySelector(".btnToggle").addEventListener("click", () => toggleRoute(ruta));
    card.querySelector(".btnExport").addEventListener("click", () => exportRoute(ruta));
    card.querySelector(".btnDelete").addEventListener("click", () => deleteRoute(ruta));
    const btnRename = card.querySelector(".btnRename");
    const nameInput = card.querySelector(".routeNameInput");
    if (btnRename && nameInput){
      btnRename.addEventListener("click", () => { applyNameToRoute(ruta, nameInput.value.trim()); renderRouteList(); });
    }
    const btnColor = card.querySelector(".btnColor");
    if (btnColor){
      btnColor.addEventListener("click", () => applyColorToRoute(ruta, colorInput.value));
    }
  });
}

function zoomToRoute(ruta){
  const layers = [];
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta) layers.push(l);
  });
  if (!layers.length) return;

  const fg = L.featureGroup(layers);
  map.fitBounds(fg.getBounds().pad(0.2));

  // seleccionar ruta
  const rf = document.getElementById("routeFilter");
  if (rf){ rf.value = ruta; }
  updateRouteMetricsBox(ruta);
}

function toggleRoute(ruta){
  if (routeHidden.has(ruta)) routeHidden.delete(ruta);
  else routeHidden.add(ruta);
  markDirty("Ocultar/mostrar ruta");
  renderRouteList();
  applyFilters();
}

function applyColorToRoute(ruta, color){
  if (!ruta) return;
  if (isPN(ruta)){ alert("Las rutas PN son siempre blancas."); return; }
  routeColors.set(ruta, color);

  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta){
      p.color = color;
      l.feature.properties = p;
      l.setPopupContent(buildPopup(p));
      applyStyle(l);
    }
  });

  markDirty("Recolor ruta");
  renderRouteList();
  applyFilters();
}

function getRouteName(ruta){
  let name = "";
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta){
      const rn = safeStr(p.ruta_nombre).trim();
      if (rn) name = rn;
    }
  });
  return name;
}

function applyNameToRoute(ruta, nombre){
  if (!ruta) return;
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta){
      p.ruta_nombre = nombre;
      l.feature.properties = p;
      l.setPopupContent(buildPopup(p));
    }
  });
  markDirty("Renombrar ruta");
}

function deleteRoute(ruta){
  if (!ruta) return;
  if (!confirm(`¿Borrar toda la ruta "${ruta}"?`)) return;

  const toRemove = [];
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta) toRemove.push(l);
  });
  toRemove.forEach(l => allLayers.removeLayer(l));

  routeColors.delete(ruta);
  routeHidden.delete(ruta);

  if (selectedLayer && !allLayers.hasLayer(selectedLayer)){
    selectedLayer = null;
    document.getElementById("selBadge").textContent = "Sin selección";
  }

  geometryVersion++; routeDistanceCache.clear();
  markDirty("Borrar ruta");
  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  updateKPIs();
}

function exportRoute(ruta){
  const features = [];
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) === ruta){
      const ll = l.getLatLng();
      l.feature.geometry.coordinates = [ll.lng, ll.lat];
      features.push(l.feature);
    }
  });
  const gj = { type:"FeatureCollection", features };
  download(`ruta_${ruta.replaceAll(" ","_")}.geojson`, JSON.stringify(gj, null, 2));
}

/* ===========================
   Guardado / exportación
=========================== */
let dirty = false;
let saveTimer = null;
const saveDot = document.getElementById("saveDot");
const saveStatus = document.getElementById("saveStatus");
const saveHint = document.getElementById("saveHint");

function setSaveUI(state, msg, hint=""){
  saveDot.classList.remove("ok","warn");
  if (state === "ok") saveDot.classList.add("ok");
  if (state === "warn") saveDot.classList.add("warn");
  saveStatus.textContent = msg;
  saveHint.textContent = hint;
}

function layersToGeoJson(onlySelected=false){
  const features = [];
  const push = (layer) => {
    if (!layer.feature) return;
    const ll = layer.getLatLng();
    layer.feature.geometry.coordinates = [ll.lng, ll.lat];
    features.push(layer.feature);
  };

  if (onlySelected){
    if (selectedLayer) push(selectedLayer);
  } else {
    allLayers.eachLayer(push);
  }

  return { type:"FeatureCollection", features };
}

function markDirty(reason=""){
  dirty = true;
  setSaveUI("warn", "Cambios pendientes…", reason ? `(${reason})` : "");
  const autoOn = document.getElementById("autoSaveToggle").checked;
  if (!autoOn) return;

  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(() => saveToDB("Auto-guardado"), 800);
}

async function saveToDB(source="Manual"){
  const payload = {
    geojson: layersToGeoJson(false),
    routeColors: Array.from(routeColors.entries()),
    routeHidden: Array.from(routeHidden.values()),
    paletteIndex,
    view: { center: map.getCenter(), zoom: map.getZoom() },
    ui: {
      routeFilter: document.getElementById("routeFilter").value,
      search: document.getElementById("searchBox").value
    }
  };
  try{
    await idbSet(STATE_KEY, payload);
    dirty = false;
    setSaveUI("ok", "Guardado", source ? `(${source})` : "");
  } catch(e){
    setSaveUI("warn", "No se pudo guardar", "(IndexedDB bloqueado o sin espacio)");
  }
}

async function loadFromDB(){
  try{ return await idbGet(STATE_KEY); } catch(e){ return null; }
}

async function clearDB(){
  try{ await idbDel(STATE_KEY); return true; } catch(e){ return false; }
}

function download(filename, text){
  const blob = new Blob([text], { type: "application/geo+json;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

/* ===========================
   Importar / añadir / exportar
=========================== */
function addGeoJsonToMap(geojson){
  const gj = normalizeGeoJson(geojson);
  if (!gj) return { added:0, skipped:0 };

  let added = 0;
  let skipped = 0;

  const layer = L.geoJSON(gj, {
    pointToLayer,
    onEachFeature,
    filter: (feature) => {
      return feature && feature.geometry && feature.geometry.type === "Point";
    }
  });

  layer.eachLayer(l => {
    const key = featureImportKey(l.feature);
    if (key && importedKeySet.has(key)){
      skipped++;
      return;
    }
    if (key) importedKeySet.add(key);
    allLayers.addLayer(l);
    added++;
  });

  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Importación");

  return { added, skipped };
}

document.getElementById("fileInput").addEventListener("change", async (ev) => {
  const files = Array.from(ev.target.files || []);
  if (!files.length) return;

  const replaceMode = document.getElementById("importReplace").checked;
  const log = document.getElementById("importLog");
  let totalAdded = 0;
  let totalSkipped = 0;

  if (replaceMode){
    clearAllMap(true);
    setSaveUI("warn", "Mapa reemplazado", "(cargando nuevos archivos)");
  }

  for (const file of files){
    try{
      const text = await file.text();
      const parsed = JSON.parse(text);
      const { added, skipped } = addGeoJsonToMap(parsed);
      totalAdded += added;
      totalSkipped += skipped;
    } catch(e){
      alert(`No pude importar "${file.name}".`);
    }
  }

  ev.target.value = "";
  fitToAll();

  if (log){
    log.innerHTML = `<b>Importación:</b> añadidos ${totalAdded} · duplicados ignorados ${totalSkipped}${replaceMode ? " · (modo reemplazar)" : ""}`;
  }
});


document.getElementById("clearMapBtn").addEventListener("click", () => {
  if (!confirm("¿Vaciar el mapa completo? Esto quita todas las incidencias cargadas.")) return;
  clearAllMap(true);
  markDirty("Vaciar mapa");
});

document.getElementById("newSessionBtn").addEventListener("click", async () => {
  if (!confirm("¿Empezar totalmente limpio? Esto vacía el mapa y borra el guardado local.")) return;
  clearAllMap(true);
  await clearDB();
  dirty = false;
  setSaveUI("ok", "Sesión limpia", "(sin guardado)");
});

document.getElementById("saveBtn").addEventListener("click", () => saveToDB("Manual"));

document.getElementById("loadBtn").addEventListener("click", async () => {
  const payload = await loadFromDB();
  if (!payload){ alert("No hay guardado todavía."); return; }

  allLayers.clearLayers();
  routeColors.clear();
  routeHidden.clear();

  if (payload.routeColors){
    for (const [k,v] of payload.routeColors) routeColors.set(k, v);
  }
  if (payload.routeHidden){
    for (const r of payload.routeHidden) routeHidden.add(r);
  }
  paletteIndex = payload.paletteIndex ?? 0;

  if (payload.geojson){
    const layer = L.geoJSON(payload.geojson, { pointToLayer, onEachFeature });
    layer.eachLayer(l => allLayers.addLayer(l));
  }

  refreshRouteFilter();
  renderRouteList();

  if (payload.ui){
    document.getElementById("routeFilter").value = payload.ui.routeFilter || "";
    document.getElementById("searchBox").value = payload.ui.search || "";
  }

  applyFilters();

  if (payload.view?.center && payload.view?.zoom !== undefined){
    map.setView([payload.view.center.lat, payload.view.center.lng], payload.view.zoom);
  } else {
    fitToAll();
  }

  dirty = false;
  setSaveUI("ok", "Cargado", "(desde guardado)");
});

document.getElementById("clearBtn").addEventListener("click", async () => {
  const ok = await clearDB();
  dirty = false;
  setSaveUI("ok", "Guardado borrado", "");
  if (!ok) alert("No se pudo borrar el guardado (IndexedDB bloqueado).");
});

document.getElementById("exportBtn").addEventListener("click", () => {
  const gj = layersToGeoJson(false);
  download("incidencias_editadas.geojson", JSON.stringify(gj, null, 2));
});

document.getElementById("exportRouteBtn").addEventListener("click", () => {
  const ruta = document.getElementById("routeFilter").value.trim();
  if (!ruta){ alert("Elige una ruta en el filtro para exportarla."); return; }
  exportRoute(ruta);
});

function fitToAll(){
  if (!allLayers.getLayers().length) return;
  const b = allLayers.getBounds();
  if (b.isValid()) map.fitBounds(b.pad(0.15));
}
document.getElementById("fitBtn").addEventListener("click", fitToAll);

document.getElementById("routeFilter").addEventListener("change", () => { applyFilters(); updateRouteMetricsBox(document.getElementById("routeFilter").value.trim()); });
document.getElementById("searchBox").addEventListener("input", () => { applyFilters(); });

/* ===========================
   Leaflet.draw (mover/editar)
=========================== */
const drawControl = new L.Control.Draw({
  position: "topright",
  draw: { polygon:false, polyline:false, rectangle:false, circle:false, circlemarker:false, marker:false },
  edit: { featureGroup: allLayers, remove: true }
});
map.addControl(drawControl);

map.on(L.Draw.Event.EDITED, (e) => {
  e.layers.eachLayer(layer => {
    if (layer.feature && layer.getLatLng){
      const ll = layer.getLatLng();
      layer.feature.geometry.coordinates = [ll.lng, ll.lat];
    }
  });
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Mover/editar geometría");
});

map.on(L.Draw.Event.DELETED, () => {
  if (selectedLayer && !allLayers.hasLayer(selectedLayer)){
    selectedLayer = null;
    document.getElementById("selBadge").textContent = "Sin selección";
  }
  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Borrar puntos");
});

/* ===========================
   Edición de punto + ruta
=========================== */
document.getElementById("savePointBtn").addEventListener("click", () => {
  if (!selectedLayer) return;

  const p = selectedLayer.feature.properties || {};
  p.ruta = document.getElementById("fRuta").value.trim();
  p.foto = document.getElementById("fFoto").value.trim();
  p.ruta_nombre = document.getElementById("fRutaNombre").value.trim();
  p.incidencia = document.getElementById("fIncidencia").value.trim();

  const ruta = getRuta(p);
  const chosen = document.getElementById("fColor").value;

  if (isPN(ruta)){
    p.color = "#ffffff";
  } else {
    p.color = chosen;
    if (ruta) routeColors.set(ruta, chosen);
  }

  selectedLayer.feature.properties = p;
  selectedLayer.setPopupContent(buildPopup(p));
  applyStyle(selectedLayer);

  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Editar punto");
  selectLayer(selectedLayer);
});

document.getElementById("deletePointBtn").addEventListener("click", () => {
  if (!selectedLayer) return;
  allLayers.removeLayer(selectedLayer);
  selectedLayer = null;
  document.getElementById("selBadge").textContent = "Sin selección";
  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Borrar punto");
});

document.getElementById("applyRouteColorBtn").addEventListener("click", () => {
  if (!selectedLayer) return;
  const ruta = document.getElementById("fRuta").value.trim();
  if (!ruta) return;
  if (isPN(ruta)){ alert("Las rutas PN son siempre blancas."); return; }
  applyColorToRoute(ruta, document.getElementById("fColor").value);
});

document.getElementById("deleteRouteBtn").addEventListener("click", () => {
  const ruta = document.getElementById("fRuta").value.trim();
  if (!ruta) return;
  deleteRoute(ruta);
});

/* ===========================
   Añadir puntos (modo)
=========================== */
let addMode = false;
document.getElementById("addMode").addEventListener("change", (e) => {
  addMode = e.target.checked;
  map.getContainer().style.cursor = addMode ? "crosshair" : "";
});

map.on("click", (ev) => {
  if (!addMode) return;
  const ll = ev.latlng;

  const feature = {
    type:"Feature",
    geometry:{ type:"Point", coordinates:[ll.lng, ll.lat] },
    properties:{ ruta:"", foto:"", incidencia:"", color:"" }
  };

  const layer = pointToLayer(feature, ll);
  layer.feature = feature;
  onEachFeature(feature, layer);
  allLayers.addLayer(layer);

  selectLayer(layer);
  refreshRouteFilter();
  renderRouteList();
  applyFilters();
  geometryVersion++; routeDistanceCache.clear();
  markDirty("Añadir punto");
});

/* ===========================
   KPIs y revisión guiada
=========================== */

let reviewRouteIdx = -1;
let reviewPointIdx = -1;
let reviewTimer = null;

function getVisibleRoutes(){
  const stats = computeRouteStats();
  const rutas = Array.from(stats.keys()).filter(r => r && r !== "(sin ruta)");
  rutas.sort((a,b)=>a.localeCompare(b,"es"));
  // aplica ocultas y filtro si hay
  const rFilter = document.getElementById("routeFilter").value.trim();
  return rutas.filter(r => !routeHidden.has(r) && (!rFilter || r === rFilter));
}

function reviewGo(delta){
  const rutas = getVisibleRoutes();
  if (!rutas.length){
    document.getElementById("revOut").textContent = "No hay rutas visibles.";
    return;
  }

  // Inicialización
  if (reviewRouteIdx < 0) reviewRouteIdx = 0;
  if (reviewPointIdx < 0) reviewPointIdx = 0;

  // Avanza/retrocede por puntos y, al terminar, salta de ruta
  let routeIdx = reviewRouteIdx;
  let pointIdx = reviewPointIdx;

  const step = (d) => {
    const ruta = rutas[routeIdx];
    const pts = getRouteLayers(ruta, true);
    if (!pts.length) return;

    pointIdx += d;

    if (pointIdx >= pts.length){
      routeIdx = (routeIdx + 1) % rutas.length;
      pointIdx = 0;
    } else if (pointIdx < 0){
      routeIdx = (routeIdx - 1 + rutas.length) % rutas.length;
      const prevPts = getRouteLayers(rutas[routeIdx], true);
      pointIdx = Math.max(prevPts.length - 1, 0);
    }

    reviewRouteIdx = routeIdx;
    reviewPointIdx = pointIdx;

    const curRuta = rutas[routeIdx];
    const list = getRouteLayers(curRuta, true);
    if (!list.length) return;

    const layer = list[pointIdx];
    const p = layer.feature?.properties || {};
    const foto = safeStr(p.foto).trim();

    const ll = layer.getLatLng();
    map.flyTo(ll, Math.max(map.getZoom(), 16), { duration: 0.8 });
    setTimeout(() => layer.openPopup(), 700);

    updateRouteMetricsBox(curRuta);
    document.getElementById("revOut").textContent =
      `Ruta ${curRuta} · ${pointIdx+1}/${list.length}${foto ? " · Foto " + foto : ""}`;
  };

  step(delta);
}

document.getElementById("revPrev").addEventListener("click", () => reviewGo(-1));
document.getElementById("revNext").addEventListener("click", () => reviewGo(+1));

document.getElementById("revPlay").addEventListener("click", () => {
  if (reviewTimer) return;
  reviewGo(+1);
  reviewTimer = setInterval(() => reviewGo(+1), 1800);
});

document.getElementById("revStop").addEventListener("click", () => {
  if (reviewTimer){ clearInterval(reviewTimer); reviewTimer = null; }
});


/* ===========================
   Medición distancia/tiempo
=========================== */
let measuring = false;
let measurePts = [];
let measureLine = null;
let measureMarkers = [];
let measureTotalKm = 0;

function haversineKm(a, b){
  const R = 6371;
  const toRad = (d)=>d*Math.PI/180;
  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
  return 2 * R * Math.asin(Math.sqrt(s));
}

function parseFotoNum(p){
  const f = safeStr(p.foto).trim();
  const n = parseInt(f, 10);
  return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
}

function getRouteLayers(ruta, onlyVisible=false){
  const arr = [];
  allLayers.eachLayer(l => {
    const p = l.feature?.properties || {};
    if (getRuta(p) !== ruta) return;
    if (onlyVisible && !layerMatchesFilters(l)) return;
    arr.push(l);
  });
  // Orden por foto si es posible (para aproximar el recorrido real)
  arr.sort((a,b) => {
    const pa = a.feature?.properties || {};
    const pb = b.feature?.properties || {};
    const na = parseFotoNum(pa);
    const nb = parseFotoNum(pb);
    if (na !== nb) return na - nb;
    const la = a.getLatLng(); const lb = b.getLatLng();
    // fallback estable
    if (la.lat !== lb.lat) return la.lat - lb.lat;
    return la.lng - lb.lng;
  });
  return arr;
}

function routeDistanceKm(ruta){
  // Cache para que el panel sea ágil
  const cacheKey = ruta + "::" + geometryVersion;
  const cached = routeDistanceCache.get(ruta);
  if (cached && cached.key === cacheKey) return cached.km;

  const layersAll = getRouteLayers(ruta, false);
  if (layersAll.length < 2){
    routeDistanceCache.set(ruta, { km: 0, key: cacheKey });
    return 0;
  }

  // 1) nube principal: quitar outliers por vecino más cercano
  const pts = layersAll.map(l => l.getLatLng());
  const nn = [];
  for (let i=0;i<pts.length;i++){
    let best = Infinity;
    for (let j=0;j<pts.length;j++){
      if (i===j) continue;
      const d = haversineKm(pts[i], pts[j]) * 1000;
      if (d < best) best = d;
    }
    if (Number.isFinite(best)) nn.push(best);
  }
  nn.sort((a,b)=>a-b);
  const med = nn.length ? nn[Math.floor(nn.length/2)] : 0;
  const thrM = Math.max(400, med * 6);

  const coreIdx = [];
  for (let i=0;i<pts.length;i++){
    let best = Infinity;
    for (let j=0;j<pts.length;j++){
      if (i===j) continue;
      const d = haversineKm(pts[i], pts[j]) * 1000;
      if (d < best) best = d;
    }
    if (best <= thrM) coreIdx.push(i);
  }

  const useIdx = (coreIdx.length >= 2) ? coreIdx : pts.map((_,i)=>i);

  // 2) longitud estimada como DIÁMETRO del árbol MST (evita rutas de 200 km por orden erróneo)
  // Prim O(n^2) (n suele ser pequeño/medio)
  const n = useIdx.length;
  const inMST = new Array(n).fill(false);
  const dist = new Array(n).fill(Infinity);
  const parent = new Array(n).fill(-1);
  dist[0] = 0;

  // acceso a puntos por índice local->global
  const P = (i) => pts[useIdx[i]];

  for (let it=0; it<n; it++){
    let u=-1, best=Infinity;
    for (let i=0;i<n;i++){
      if (!inMST[i] && dist[i] < best){
        best = dist[i];
        u = i;
      }
    }
    if (u === -1) break;
    inMST[u] = true;

    for (let v=0; v<n; v++){
      if (inMST[v]) continue;
      const dKm = haversineKm(P(u), P(v)); // km
      if (dKm < dist[v]){
        dist[v] = dKm;
        parent[v] = u;
      }
    }
  }

  // construir adjacency del MST (pesos en km)
  const adj = Array.from({length:n}, ()=>[]);
  for (let v=1; v<n; v++){
    const u = parent[v];
    if (u < 0) continue;
    const w = haversineKm(P(u), P(v));
    adj[u].push([v,w]);
    adj[v].push([u,w]);
  }

  function farthest(start){
    const d = new Array(n).fill(-1);
    d[start] = 0;
    const q = [start];
    for (let qi=0; qi<q.length; qi++){
      const u = q[qi];
      for (const [v,w] of adj[u]){
        if (d[v] < 0){
          d[v] = d[u] + w;
          q.push(v);
        }
      }
    }
    let mx = 0, idx = start;
    for (let i=0;i<n;i++){
      if (d[i] > mx){
        mx = d[i];
        idx = i;
      }
    }
    return [idx, mx];
  }

  const [a] = farthest(0);
  const [,diam] = farthest(a);

  // guardamos
  routeDistanceCache.set(ruta, { km: diam, key: cacheKey });
  return diam;
}

function fmtH(h){
  const m = Math.round(h*60);
  const hh = Math.floor(m/60);
  const mm = m%60;
  if (hh <= 0) return `${mm} min`;
  return `${hh} h ${String(mm).padStart(2,"0")} min`;
}

function getSpeedStd(){
  const a = document.getElementById("speedStdRoutes");
  const b = document.getElementById("speedStd");
  const v = parseFloat((a?.value ?? b?.value ?? "4") || "4");
  return (v > 0) ? v : 4;
}
function getSpeedAcc(){
  const a = document.getElementById("speedAccRoutes");
  const b = document.getElementById("speedAcc");
  const v = parseFloat((a?.value ?? b?.value ?? "2.5") || "2.5");
  return (v > 0) ? v : 2.5;
}

function fmtRouteKm(ruta){
  const km = routeDistanceKm(ruta);
  return km.toFixed(2);
}
function fmtRouteTime(ruta){
  const km = routeDistanceKm(ruta);
  const std = getSpeedStd();
  const acc = getSpeedAcc();
  const tStd = fmtH(km / std);
  const tAcc = fmtH(km / acc);
  return `${tStd} · ${tAcc}`;
}

function updateRouteMetricsBox(ruta){
  const out = document.getElementById("routeMetricsOut");
  if (!out) return;
  if (!ruta){
    out.textContent = "Selecciona una ruta para ver distancia y tiempo.";
    return;
  }
  const km = routeDistanceKm(ruta);
  const std = getSpeedStd();
  const acc = getSpeedAcc();
  out.textContent = `Ruta: ${ruta} · Distancia: ${km.toFixed(2)} km · Tiempo estándar: ${fmtH(km/std)} · Tiempo adaptado: ${fmtH(km/acc)}`;
}


function updateMeasureOut(){
  const std = parseFloat(document.getElementById("speedStd").value || "4");
  const acc = parseFloat(document.getElementById("speedAcc").value || "2.5");

  const hoursStd = (std > 0) ? (measureTotalKm / std) : 0;
  const hoursAcc = (acc > 0) ? (measureTotalKm / acc) : 0;

  function fmtH(h){
    const m = Math.round(h*60);
    const hh = Math.floor(m/60);
    const mm = m%60;
    if (hh <= 0) return `${mm} min`;
    return `${hh} h ${String(mm).padStart(2,"0")} min`;
  }

  document.getElementById("measureOut").textContent =
    `Distancia: ${measureTotalKm.toFixed(2)} km · Tiempo estándar: ${fmtH(hoursStd)} · Tiempo adaptado: ${fmtH(hoursAcc)}`;
}

function redrawMeasure(){
  if (measureLine) map.removeLayer(measureLine);
  measureMarkers.forEach(m => map.removeLayer(m));
  measureMarkers = [];

  if (measurePts.length >= 2){
    measureLine = L.polyline(measurePts, { weight: 4 }).addTo(map);
  } else {
    measureLine = null;
  }

  measurePts.forEach((pt) => {
    const m = L.circleMarker(pt, { radius:5, weight:2, fillOpacity:1 }).addTo(map);
    measureMarkers.push(m);
  });

  measureTotalKm = 0;
  for (let i=1;i<measurePts.length;i++){
    measureTotalKm += haversineKm(measurePts[i-1], measurePts[i]);
  }
  updateMeasureOut();
}

document.getElementById("measureStart").addEventListener("click", () => {
  measuring = true;
  map.getContainer().style.cursor = "crosshair";
});

document.getElementById("measureFinish").addEventListener("click", () => {
  measuring = false;
  map.getContainer().style.cursor = addMode ? "crosshair" : "";
});

document.getElementById("measureClear").addEventListener("click", () => {
  measuring = false;
  measurePts = [];
  redrawMeasure();
  map.getContainer().style.cursor = addMode ? "crosshair" : "";
});

document.getElementById("measureFit").addEventListener("click", () => {
  if (!measureLine) return;
  map.fitBounds(measureLine.getBounds().pad(0.2));
});

document.getElementById("speedStd").addEventListener("input", ()=>{ updateMeasureOut(); renderRouteList(); updateRouteMetricsBox(document.getElementById("routeFilter").value.trim()); });
document.getElementById("speedAcc").addEventListener("input", ()=>{ updateMeasureOut(); renderRouteList(); updateRouteMetricsBox(document.getElementById("routeFilter").value.trim()); });

map.on("click", (ev) => {
  if (!measuring) return;
  measurePts.push(ev.latlng);
  redrawMeasure();
});

/* ===========================
   Tabs
=========================== */
document.querySelectorAll(".tab").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");

    const key = btn.getAttribute("data-tab");
    document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
    document.getElementById("tab-" + key).classList.add("active");

    // Actualiza KPIs al entrar en análisis
    if (key === "analisis") updateKPIs();
  });
});

/* ===========================
   Arranque
=========================== */
(async function boot(){
  const payload = await loadFromDB();
  if (payload){
    setSaveUI("ok", "Guardado detectado", "(pulsa «Cargar guardado» o «Empezar limpio»)");
  } else {
    setSaveUI("ok", "Listo", "(importa GeoJSON; usa «reemplazar» para evitar triplicados)");
  }
  updateKPIs(0);
  updateRouteMetricsBox("");
})();

// Autosave al salir
window.addEventListener("beforeunload", (e) => {
  if (!dirty) return;
  const autoOn = document.getElementById("autoSaveToggle").checked;
  if (autoOn){
    saveToDB("Auto (al salir)");
  } else {
    e.preventDefault();
    e.returnValue = "";
  }
});
</script>
</body>
</html>
